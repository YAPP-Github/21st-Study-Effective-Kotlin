# 아이템2: 변화로부터 코드를 보호하려면 추상화를 사용하라

(아이템 27)

> 함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있다. 그리고 이후에 실질적인 코드를 원하는 대로 수정할 수 있다. (중략) 추상화를 통해 변화로부토 코드를 보호하는 행위가 어떤 자유를 갖는지 알아보자.
> 

### 상수를 이용한 추상화

- 리터럴을 상수 프로퍼티로 변경하면 값에 의미있는 이름을 붙일 수 있어 이해하기 쉽다.
- 나중에 값을 쉽게 변경할 수 있다.

### 동작을 함수로 래핑

- 많이 사용되는 알고리즘은 함수로 추상화 시키면 유지보수성이 좋아지고, 사용 방법을 외울 필요가 없음.
    
    ```kotlin
    fun Context.toast(...) { Toast.makeText(...,...).show()}
    
    ...
    btn.setOnclickListener{ toast(메세지, 토스트 클래스 필드)}
    ```
    

- 변화에 대응하기 위해서 생각할 것
    - 함수의 이름을 바꾸는 것으로 대응하는 것은 위험하다. 이름의 변경은 쉽지만 파라미터까지 한번에 바꾸기 쉽지 않기 때문이다. 또한 다른 모듈이 해당 함수에 의존하고 있을 수도 있다.
        - 만약 메시지를 snackBar를 이용해 보여주는 것으로 변화된다면, 해당 함수의 이름을 변경해야 할 것임.
            
            ```kotlin
            fun Context.snackBar(...) { SnackBar.makeText(...,...).show()}
            btn.setOnclickListener{ snackBar(메세지, 스낵바 클래스 필드 )} // 이름과 파라미터 둘 다 변경
            ```
            
    
    - 앞에서는 toast(), snackBar() 등은 재사용성 목적에서는 괜찮다. 하지만 메세지를 출력한다는 관점에서는 토스트인지, 스낵바인지 정보가 필요하지도 않고 중요하지도 않고, 변화가 필요하다면 특히 더 그렇다. 이런 경우 조금 더 추상화된 이름을 도입해 목적을 달성할 수 있다.
    
    ```kotlin
    fun Context.showMessage(...){ // 더 추상적인 이름 -> 변경할 필요 없음 : 가장 중요한 추상화
    	// 토스트나 스낵바를 이용해 메세지 보여주기 -> 내용만 변경하면 된다.
    }
    ```
    
    <aside>
    💡 함수 이름 (을 포함한 시그니처)는 함수가 어떤 추상화를  표현하는지 알려주기 때문에 매우 중요
    
    </aside>
    
- 함수의 한계
    - 상태를 유지하지 않음
    - 시그니처 변경시 프로그램 전체에 큰 영향 줄 수 있음

## 함수를 클래스로 래핑

- 장점
    - 상태를 갖고, 많은 함수를 가질 수 있음.
    - 의존성 주입 프레임워크로 생성을 위임할수 있음
    - mock 객체를 활용해서 해당 클래스에 의존하는 다른 클래스의 기능을 테스트 가능.
    - 메서드를 쉽게 추가 가능
- 한계
    - 클래스가 final 이라면, 해당 타입 뒤에 어떤 구현이 있는지 알 수 있음

### 인터페이스 뒤에 클래스 숨기기

- 내부 클래스의 가시성을 제한하고 인터페이스만 노출하는 방식으로 구현을 추상화하고, 사용자가 추상화된 인터페이스에 의존하게 만들어 커플링을 줄인다.
    - 사용자가 클래스를 직접 사용하지 못함 → 제작자의 의도대로 구현을 변경 가능
- 인터페이스만 제공하고, 플랫폼에 맞는 네이티브 구현체를 사용할 수도 있음.
    - listOf 인터페이스
- 인터페이스만 제공하고, 플랫폼에 맞는 구현( ≠ 구현체) 을 사용할 수 있음
    - 공통 모듈에서 추상화된 인터페이스를 제공
    - IOS의 경우 스낵바, 토스트가 아닌 Alert 등
- mockking보다 faking이 간단하므로, 별도의 모킹 라이브러리를 사용하지 않아도 된다. `← need discussion`
- 선언과 사용이 분리되어 있음 → 구현체를 자유롭게 변경할 수 있지만, 사용 방법을 변경하려면 인터페이스 자체를 변경해야함      `← need discussion`

```kotlin
interface MessageDisplay { // 공통 모듈에 넣을 수 있고, 다른 구현체를 만들기 편리
	fun show(	message: String, duration: MessageLength = LONG) // 사용자가 의존
}

class ToastDisplay(val context: Context): MessageDisplay { //
	override fun show(val message: Stirng, duration: MessageLength){
		val totalDuratin = when(duration){
			SHORT -> LENGTH.SHORT //Toast.LENGTH_SHORT 오타!
			LONG -> LENGTH.LONG //Toast.LENGTH_LONG 오타!
		}

		Toast.makeText(context,message,toastDuration).show() // 토스트 띄워주는 알고리즘을 캡슐화 
	}
}

enum class MessageLength {SHORT,LONG}
```

### Id만들기

```kotlin
var nextId: Int = 0
val newId = nextId++ // 사용
val newNewId = nextId -- // 잘못된 사용 가능
val newNewNewId = nextId // 잘못된 사용 가능
```

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId ++ // 혹은, id를 음수로 주고 싶어도 안전하게 변경 가능
val newId = getNextId() // 함수를 이용해 코드를 "id 생성방식의 변경"으로부터 보호
```

ID 타입 변경에 대응 (id를 Int → String으로 변경할 경우)

```kotlin

data class Id(private val id: Int)
private var nextId: Int = 0

**fun getNextId()**: Id = Id(nextId++) // 클라이언트 입장에서 getNextId()만 사용한다. 
```

- 더 추상화할 수 있게 되었지만, 사용하고 이해하는 것이 어려워 졌음.

### 추상화에 추가적으로 활용 가능한 도구

- 제너릭 타입 파라미터 사용
- 내부 클래스를 추출
- 생성 제한 (객체를 팩토리 함수로만 생성할 수 있게 만드는 등) → ‘추상화 설계’ 단원에서 다룬다

### 추상화의 문제점

1. 추상화에는 새로운 비용이 발생한다. 새로 읽는 사람은 해당 추상화 방식을 배워야 한다. 
2. 추상화를 무한하게 할 수 있지만, 득보다 실이 많아지는 지점이 있음.
    - showMessage가 스낵바를 띄울 것으로 예상하거나, Toast 띄우는 코드에 문제가 있는 경우 찾기 힘들 수 있음
    - 코드 자체를 이해하기 어려울 수 있음

⇒ 단위 테스트, 문서의 예제를 통해 추상화가 어떻게 사용되는지 살펴봐야 한다. 

### 균형 맞추기

- 균형점을 결정하는 요소
    - 팀의 크기와 경험, 프로젝트 크기, feature set(특징 크기), 도메인 지식
    - 적절한 균형을 맞추는 것은 프로젝트마다 다르고, 거의 감각에 의존해야하는 예술로 수백시간 이상의 경험 필요
- 사용 가능한 규칙
    - 많은 개발자가 참여하는 프로젝트는 객체의 생성과 사용 방법을 변경하기 어려우므로 추상화 하는 것이 좋다. 최대한 모듈과 부분을 분리하는 것이 좋다.
    - DI 프레임워크를 사용하면, 생성의 복잡성을 신경쓰지 않아도 된다.
    - 테스트를 하거나 다른 어플리케이션 기반으로 새로운 어플리케이션을 만든다면 추상화를 사용하는 것이 좋다
    - 프로젝트가 작고 실험적이면 추상화를 안하고 직접 변경해도된다.

항상 무언가 변화할 수 있다고 생각할 것! 

- 토스트 출력 API는 가능성이 낮지만, 출력하는 방식은 변경될 수 있음 (스낵바 등으로)
- 더 일반적이거나 플랫폼 독립적인 매커니즘이 필요한지, 그 확률이 어느정도인지는 경험을 해 보면 알 수 있게 된다.

### 정리

- 추상화는 중복 제거 뿐 아니라, 코드를 변경해야 할 때 도움이 된다.
- 사용이 어렵지만 배우고 이해해야 한다.
- 결과를 이해하기 어려운 단점도 있다.
- 추상화가 너무 많거나 너무 적은 상황 모두 좋지 않다.