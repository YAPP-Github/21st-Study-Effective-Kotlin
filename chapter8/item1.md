## `Iterable`과 `Sequence` 의 컬렉션 연산

`Iterable` : 연산을 사용할 때 마다 연산이 이루어져, List가 만들어짐

`Sequence` : `toList`, `count` 등의 최종 연산이 이루어질 때 수행

## 시퀀스를 이용할 때 장점

---

### 자연스러운 처리 순서 유지

- 출력 결과를 확인했을 때 기존의 요소 순서를 유지하게 됨

### 최소한만 연산

- 중간 처리 단계를 모든 요소에 직접 적용할 필요가 없는 경우 좋음
- find, first, take, any, all, none, indexOf
- ex) `find { it < 5 }` 같은 경우 전체 요소가 10이라면 절반만에 끝나게 됨

### 무한 시퀀스 형태로 사용 가능

- `take(10)` 이 만족될 때 까지만 연산이 일어나므로, 구체적인 범위 지정 없이 필요한 값을 가져갈 수 있음
   ![image](https://user-images.githubusercontent.com/70064912/218126889-d5110ffb-0cb5-455b-9bee-7f1309ddc462.png)

    
- 종결 연산으로 `take`와 `first` 정도만 사용하는 것이 좋음
    - 이외에는 무한 반복에 빠지는 경우가 많음

### 각각의 단계에서 컬렉션을 만들어내지 않음

- 컬렉션은 map, filter등 각각의 연산에서 새로운 객체를 만들어 내지만, 시퀀스는 아님
- **데이터가 많은 경우,** **여러 처리 단계를 가지는 경우** 시퀀스를 사용하는 것이 좋음

## 시퀀스가 더 느린경우

- sorted의 경우 sequence → list → sort를 처리하므로 **더 느리다**
- 또한 **무한 시퀀스에 sorted를 사용**하면 무한 반복에 빠짐

## Java Stream과 Kotlin Sequence의 차이

- **Sequence가 더 많은 처리 함수를 가지고, 더 사용하기 쉬움**
- 자바 스트림은 병렬 모드로 실행할 수 있음, 그러나 결함이 있는데 조심해야 함**(병렬 작업이 독립적인 작업이 아니라면 성능 문제가 생김)**
- **Sequence는 멀티 플랫폼에서 모두 사용 가능, 자바는 JVM 8버전 이상 + 코틀린/JVM에서만 동작**

`즉, 병렬 모드가 필요하지 않다면 sequence`

## Kotlin Sequence 디버깅

- `Kotlin Sequence Debugger`

## 정리

무거운 객체나, 규모가 큰 컬렉션을 여러 단계에 걸쳐서 처리할 때 → **시퀀스**

else → 컬렉션
